var fs = require('fs');
var utils = require('utils');


exports.Statistics = function (config) {
	var me = this;

	me.calculateSpeed = function (positions) {
		console.log('Calc Speed');

		var degToKm = 40074/360;

		var speed = [];
		var maxV = 0;

		for (var i = 0; i < positions.length-1; i++) {
			var dx = positions[i].x - positions[i+1].x;
			var dy = positions[i].y - positions[i+1].y;

			dx *= degToKm*Math.cos(positions[i].y*Math.PI/180);
			dy *= degToKm;

			var r = Math.sqrt(dx*dx + dy*dy);
			var v = r/(config.timeStepSeconds/3600);

			speed[i] = v;
			if (maxV < v) maxV = v;
		}
		
		console.log(maxV);
	}

	me.calculateGraph = function (events) {
		console.log('Calc Graph');

		var ignoreContacts = {};
		fs.readFileSync('data/contacts/ignore_nodes.tsv', 'utf8').split('\n').forEach(function (contact) {
			ignoreContacts[contact] = true;
		});

		var knownNodes = {};
		utils.readListOfObjects('data/contacts/known_nodes.tsv').forEach(function (node) {
			knownNodes[node.Name] = node;
		})


		var nodes = {};
		var edges = {};
		var count = 0;

		var connections = events.map(function (event) {
			var addresses = event.to.concat([event.from]);

			// remove duplicates
			for (var i = 0; i < addresses.length; i++) {
				if (addresses[i]) {
					for (var j = i+1; j < addresses.length; j++) {
						if (addresses[i].contact == addresses[j].contact) {
							addresses[i] = false;
							break;
						}
					}
				}
			}

			// Filter
			addresses = addresses.filter(function (address) {
				if (!address) return false;
				if (ignoreContacts[address.contact]) return false;
				return true;
			})

			// Add nodes
			addresses.forEach(function (address) {
				var contact = address.contact;
				if (!nodes[contact]) nodes[contact] = {label:contact, count:0, intensity:0, weight:0, edges:0, use:false};
				nodes[contact].count++;
				nodes[contact].intensity += 1/addresses.length;
			})

			return addresses;
		});

		connections.forEach(function (addresses) {
			// Add edge
			if (addresses.length > 1) {
				var weight = 1/(addresses.length-1) + 0.01;
				for (var i = 0; i < addresses.length; i++) {
					var contact1 = addresses[i].contact;
					for (var j = i+1; j < addresses.length; j++) {
						var contact2 = addresses[j].contact;

						if (nodes[contact1] && nodes[contact2]) {
							var contactA, contactB;
							if (contact1 < contact2) {
								contactA = contact1; contactB = contact2;
							} else {
								contactA = contact2; contactB = contact1;
							}
							
							var edgeName = contactA+'_'+contactB;


							if (!edges[edgeName]) edges[edgeName] = {source:contactA, target:contactB, weight:0};

							nodes[contact1].edges  += 1;
							nodes[contact2].edges  += 1;

							nodes[contact1].weight += weight;
							nodes[contact2].weight += weight;

							edges[edgeName].weight += weight;
						}
					}
				}
			}
		})

		nodeList = Object.keys(nodes).map(function (key) {
			var node = nodes[key];
			
			node.ok = false;
			if (!node) return false;
			if (node.weight < 10) return false; //5
			if (node.edges  < 10) return false;
			if (node.count  < 20) return false; //10

			var size = node.weight + node.intensity;

			node.ok = true;
			node.maxWeight = 0;
			return [node.label, node.label, size.toFixed(2), node.weight, node.edges, node.count].join('\t');
		}).filter(function (node) {
			return node;
		});
		nodeList.unshift('Id\tLabel\tSize');

		fs.writeFileSync('nodes.csv', nodeList.join('\n'), 'utf8');

		edgeList = Object.keys(edges).map(function (key) {
			var edge = edges[key];

			if (!nodes[edge.source].ok) return false;
			if (!nodes[edge.target].ok) return false;

			if (nodes[edge.source].maxWeight < edge.weight) nodes[edge.source].maxWeight = edge.weight;
			if (nodes[edge.target].maxWeight < edge.weight) nodes[edge.target].maxWeight = edge.weight;

			return edge;
		}).filter(function (edge) {
			return edge;
		});

		edgeList = edgeList.map(function (edge) {
			var f = Math.min(nodes[edge.source].maxWeight, nodes[edge.target].maxWeight);
			return [edge.source, edge.target, edge.weight/f, 'Undirected'].join('\t');
		})
		;
		edgeList.unshift('Source\tTarget\tWeight\tType');

		fs.writeFileSync('edges.csv', edgeList.join('\n'), 'utf8');

		console.log(nodeList.length, edgeList.length);
	}

	return me;
}
